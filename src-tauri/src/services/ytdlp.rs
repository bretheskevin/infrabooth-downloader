use std::path::PathBuf;
use tauri::{AppHandle, Emitter};
use tauri_plugin_shell::{process::CommandEvent, ShellExt};

use crate::models::error::YtDlpError;
use crate::services::storage::load_tokens;

/// Get the path to the ffmpeg sidecar binary.
///
/// Checks multiple naming conventions:
/// - Dev mode: `ffmpeg` (no suffix)
/// - Production: `ffmpeg-{arch}-{os}` (with platform suffix)
fn get_ffmpeg_path() -> Option<PathBuf> {
    let exe_path = std::env::current_exe().ok()?;
    let exe_dir = exe_path.parent()?;

    // Build list of names to check (dev mode first, then platform-specific)
    #[cfg(target_os = "macos")]
    let names: &[&str] = if cfg!(target_arch = "aarch64") {
        &["ffmpeg", "ffmpeg-aarch64-apple-darwin"]
    } else {
        &["ffmpeg", "ffmpeg-x86_64-apple-darwin"]
    };

    #[cfg(target_os = "windows")]
    let names: &[&str] = &["ffmpeg.exe", "ffmpeg-x86_64-pc-windows-msvc.exe"];

    #[cfg(target_os = "linux")]
    let names: &[&str] = &["ffmpeg", "ffmpeg-x86_64-unknown-linux-gnu"];

    for name in names {
        let path = exe_dir.join(name);
        if path.exists() {
            return Some(path);
        }
    }

    None
}

/// Playlist context for track numbering.
#[derive(Debug, Clone)]
pub struct PlaylistContext {
    /// 1-indexed position in playlist
    pub track_position: u32,
    /// Total number of tracks in playlist
    pub total_tracks: u32,
}

/// Configuration for downloading a track directly to final MP3 output.
pub struct TrackDownloadToMp3Config {
    pub track_url: String,
    pub track_id: String,
    pub output_dir: PathBuf,
    /// Playlist context for track numbering (None for single tracks)
    pub playlist_context: Option<PlaylistContext>,
    /// Artist name from SoundCloud API (used for filename)
    pub artist: String,
    /// Track title from SoundCloud API (used for filename)
    pub title: String,
}

/// Progress update from yt-dlp.
#[derive(Debug, Clone, serde::Serialize)]
pub struct DownloadProgress {
    pub percent: f32,
    pub speed: Option<String>,
    pub eta: Option<String>,
}

/// Download progress event payload for frontend communication.
#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DownloadProgressEvent {
    pub track_id: String,
    pub status: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub percent: Option<f32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<DownloadErrorPayload>,
}

/// Error payload for download progress events.
#[derive(Debug, Clone, serde::Serialize)]
pub struct DownloadErrorPayload {
    pub code: String,
    pub message: String,
}

/// Build the output template for yt-dlp based on context.
///
/// - Single track: `Artist - Title.mp3`
/// - Playlist track: `01 - Artist - Title.mp3` (zero-padded based on total)
fn build_output_template(output_dir: &PathBuf, playlist_context: &Option<PlaylistContext>) -> String {
    let dir_str = output_dir.to_string_lossy();

    match playlist_context {
        Some(ctx) => {
            // Determine padding width based on total tracks
            let width = if ctx.total_tracks < 10 {
                1
            } else if ctx.total_tracks < 100 {
                2
            } else {
                3
            };
            // Use yt-dlp's playlist_index with zero-padding
            // Artist/title are injected via --replace-in-metadata from SoundCloud API data
            format!(
                "{}/%(playlist_index)0{}d - %(artist)s - %(title)s.%(ext)s",
                dir_str, width
            )
        }
        None => {
            // Single track: Artist - Title.mp3
            // Artist/title are injected via --replace-in-metadata from SoundCloud API data
            format!("{}/%(artist)s - %(title)s.%(ext)s", dir_str)
        }
    }
}

/// Download a track directly to MP3 format using yt-dlp.
///
/// This function downloads and converts to MP3 in a single step using yt-dlp's
/// built-in conversion with 320kbps bitrate. Filenames are generated by yt-dlp
/// from track metadata with cross-platform sanitization.
///
/// If OAuth tokens are available, they will be used for higher quality downloads.
/// Otherwise, yt-dlp will download public content without authentication.
///
/// Progress events are emitted via Tauri events to the frontend.
pub async fn download_track_to_mp3<R: tauri::Runtime>(
    app: &AppHandle<R>,
    config: TrackDownloadToMp3Config,
) -> Result<PathBuf, YtDlpError> {
    // Try to load tokens - authentication is optional for public content
    let tokens = load_tokens().ok().flatten();

    let output_template = build_output_template(&config.output_dir, &config.playlist_context);

    let mut args = vec![
        "-v".to_string(),
        "-f".to_string(),
        // Prefer MP3 format to skip conversion when available, fall back to best audio
        "bestaudio[ext=mp3]/bestaudio".to_string(),
        "--no-playlist".to_string(),
        "-x".to_string(),
        "--audio-format".to_string(),
        "mp3".to_string(),
        "--audio-quality".to_string(),
        "320K".to_string(),
        // Inject our metadata to override yt-dlp's extracted values for filename
        "--replace-in-metadata".to_string(),
        "artist".to_string(),
        ".*".to_string(),
        config.artist.clone(),
        "--replace-in-metadata".to_string(),
        "title".to_string(),
        ".*".to_string(),
        config.title.clone(),
        "-o".to_string(),
        output_template,
        // Cross-platform filename sanitization (removes :, *, ?, etc.)
        "--windows-filenames".to_string(),
        // Don't overwrite existing files
        "--no-overwrites".to_string(),
        "--newline".to_string(),
        config.track_url.clone(),
    ];

    // Add OAuth token if available (enables higher quality downloads for authenticated users)
    if let Some(ref t) = tokens {
        args.insert(0, "--extractor-args".to_string());
        args.insert(1, format!("soundcloud:oauth_token={}", t.access_token));
    }

    // Add ffmpeg location if available
    if let Some(ffmpeg_path) = get_ffmpeg_path() {
        args.insert(0, "--ffmpeg-location".to_string());
        args.insert(1, ffmpeg_path.to_string_lossy().to_string());
    }

    // Add playlist index if in playlist context
    if let Some(ctx) = &config.playlist_context {
        args.insert(0, "--playlist-items".to_string());
        args.insert(1, ctx.track_position.to_string());
    }

    let shell = app.shell();
    let (mut rx, _child) = shell
        .sidecar("yt-dlp")
        .map_err(|_| YtDlpError::BinaryNotFound)?
        .args(&args)
        .spawn()
        .map_err(|_| YtDlpError::BinaryNotFound)?;

    let mut last_error: Option<String> = None;
    let mut output_path: Option<PathBuf> = None;

    while let Some(event) = rx.recv().await {
        match event {
            CommandEvent::Stdout(line_bytes) => {
                let line = bytes_to_string(&line_bytes);
                log::info!("yt-dlp stdout: {}", line);

                // Parse the destination path from yt-dlp output
                if let Some(path) = parse_destination(&line) {
                    output_path = Some(PathBuf::from(path));
                }

                if let Some(progress) = parse_progress(&line) {
                    let _ = app.emit(
                        "download-progress",
                        DownloadProgressEvent {
                            track_id: config.track_id.clone(),
                            status: "downloading".to_string(),
                            percent: Some(progress.percent),
                            error: None,
                        },
                    );
                }
            }
            CommandEvent::Stderr(line_bytes) => {
                let line = bytes_to_string(&line_bytes);
                log::info!("yt-dlp stderr: {}", line);
                last_error = Some(line.clone());

                // Check for geo-block patterns first (most specific)
                if detect_geo_block(&line).is_some() {
                    log::info!("Track {} geo-blocked in region", config.track_id);
                    return Err(YtDlpError::GeoBlocked);
                }
                // HTTP 403 can also indicate geo-block
                if line.contains("HTTP Error 403") {
                    log::info!("Track {} geo-blocked (HTTP 403)", config.track_id);
                    return Err(YtDlpError::GeoBlocked);
                }
                if line.contains("HTTP Error 429") || line.contains("rate limit") {
                    return Err(YtDlpError::RateLimited);
                }
                // Check for unavailability patterns before generic 404
                if let Some(unavailable_reason) = detect_unavailability(&line) {
                    log::info!("Track {} unavailable: {}", config.track_id, unavailable_reason);
                    return Err(YtDlpError::DownloadFailed(unavailable_reason));
                }
                // HTTP 404 indicates track not found / unavailable
                if line.contains("HTTP Error 404") {
                    log::info!("Track {} not found (HTTP 404)", config.track_id);
                    return Err(YtDlpError::DownloadFailed(
                        "Track unavailable - may have been removed or made private".to_string(),
                    ));
                }
            }
            CommandEvent::Terminated(payload) => {
                if payload.code != Some(0) {
                    log::error!(
                        "yt-dlp terminated with code {:?}: {:?}",
                        payload.code,
                        last_error
                    );
                    return Err(YtDlpError::DownloadFailed(
                        last_error.unwrap_or_else(|| "Unknown error".to_string()),
                    ));
                }
            }
            _ => {}
        }
    }

    // Verify output file exists
    let final_path = output_path.ok_or_else(|| {
        YtDlpError::DownloadFailed("Could not determine output filename".to_string())
    })?;

    if !final_path.exists() {
        return Err(YtDlpError::DownloadFailed(
            "Output file was not created".to_string(),
        ));
    }

    Ok(final_path)
}

/// Get the yt-dlp version.
pub async fn get_version<R: tauri::Runtime>(
    app: &tauri::AppHandle<R>,
) -> Result<String, YtDlpError> {
    let shell = app.shell();
    let (mut rx, _child) = shell
        .sidecar("yt-dlp")
        .map_err(|_| YtDlpError::BinaryNotFound)?
        .args(["--version"])
        .spawn()
        .map_err(|_| YtDlpError::BinaryNotFound)?;

    let mut version = String::new();

    while let Some(event) = rx.recv().await {
        match event {
            CommandEvent::Stdout(line_bytes) => {
                let line = bytes_to_string(&line_bytes);
                version = line.trim().to_string();
            }
            CommandEvent::Terminated(payload) => {
                if payload.code != Some(0) {
                    return Err(YtDlpError::BinaryNotFound);
                }
            }
            _ => {}
        }
    }

    if version.is_empty() {
        return Err(YtDlpError::BinaryNotFound);
    }

    Ok(version)
}

fn bytes_to_string(bytes: &[u8]) -> String {
    String::from_utf8_lossy(bytes).to_string()
}

/// Parse the destination path from yt-dlp output.
///
/// Looks for lines like: `[download] Destination: /path/to/file.mp3`
/// or `[ExtractAudio] Destination: /path/to/file.mp3`
fn parse_destination(line: &str) -> Option<String> {
    if line.contains("Destination:") {
        line.split("Destination:")
            .nth(1)
            .map(|s| s.trim().to_string())
    } else {
        None
    }
}

/// Detect geographic restriction from yt-dlp stderr output.
///
/// Returns Some with a user-friendly message if geo-block patterns are found.
fn detect_geo_block(stderr: &str) -> Option<String> {
    let patterns = [
        "not available in your country",
        "geo restricted",
        "geo-restricted",
        "not available in your region",
        "blocked in your country",
        "not available in your location",
        "is not available for playback",
        "not available in this country",
    ];

    let stderr_lower = stderr.to_lowercase();
    for pattern in patterns {
        if stderr_lower.contains(pattern) {
            return Some("Geographic restriction by rights holder".to_string());
        }
    }
    None
}

/// Detect unavailable/removed/private track from yt-dlp stderr output.
///
/// Returns Some with a user-friendly message if unavailability patterns are found.
/// Note: Geo-block detection should be checked first as it's more specific.
fn detect_unavailability(stderr: &str) -> Option<String> {
    let patterns = [
        "video unavailable",
        "this video is not available",
        "private video",
        "this track was removed",
        "does not exist",
        "video is unavailable",
        "content is not available",
        "has been removed",
        "no longer available",
        "track is private",
        "is private",
    ];

    let stderr_lower = stderr.to_lowercase();
    for pattern in patterns {
        if stderr_lower.contains(pattern) {
            return Some("Track unavailable - may have been removed or made private".to_string());
        }
    }
    None
}

fn parse_progress(line: &str) -> Option<DownloadProgress> {
    if !line.contains("[download]") || !line.contains('%') {
        return None;
    }

    let parts: Vec<&str> = line.split_whitespace().collect();

    let percent = parts.iter().find_map(|part| {
        if part.ends_with('%') {
            part.trim_end_matches('%').parse::<f32>().ok()
        } else {
            None
        }
    })?;

    let speed = parts
        .iter()
        .position(|&p| p == "at")
        .and_then(|i| parts.get(i + 1))
        .map(|s| s.to_string());

    let eta = parts
        .iter()
        .position(|&p| p == "ETA")
        .and_then(|i| parts.get(i + 1))
        .map(|s| s.to_string());

    Some(DownloadProgress {
        percent: percent / 100.0,
        speed,
        eta,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_output_template_single_track() {
        let output_dir = PathBuf::from("/downloads");
        let template = build_output_template(&output_dir, &None);
        assert_eq!(
            template,
            "/downloads/%(artist)s - %(title)s.%(ext)s"
        );
    }

    #[test]
    fn test_build_output_template_playlist_single_digit() {
        let output_dir = PathBuf::from("/downloads");
        let ctx = Some(PlaylistContext {
            track_position: 1,
            total_tracks: 5,
        });
        let template = build_output_template(&output_dir, &ctx);
        assert_eq!(
            template,
            "/downloads/%(playlist_index)01d - %(artist)s - %(title)s.%(ext)s"
        );
    }

    #[test]
    fn test_build_output_template_playlist_double_digit() {
        let output_dir = PathBuf::from("/downloads");
        let ctx = Some(PlaylistContext {
            track_position: 5,
            total_tracks: 47,
        });
        let template = build_output_template(&output_dir, &ctx);
        assert_eq!(
            template,
            "/downloads/%(playlist_index)02d - %(artist)s - %(title)s.%(ext)s"
        );
    }

    #[test]
    fn test_build_output_template_playlist_triple_digit() {
        let output_dir = PathBuf::from("/downloads");
        let ctx = Some(PlaylistContext {
            track_position: 1,
            total_tracks: 150,
        });
        let template = build_output_template(&output_dir, &ctx);
        assert_eq!(
            template,
            "/downloads/%(playlist_index)03d - %(artist)s - %(title)s.%(ext)s"
        );
    }

    #[test]
    fn test_parse_destination_download() {
        let line = "[download] Destination: /path/to/Artist - Title.mp3";
        assert_eq!(
            parse_destination(line),
            Some("/path/to/Artist - Title.mp3".to_string())
        );
    }

    #[test]
    fn test_parse_destination_extract_audio() {
        let line = "[ExtractAudio] Destination: /path/to/file.mp3";
        assert_eq!(
            parse_destination(line),
            Some("/path/to/file.mp3".to_string())
        );
    }

    #[test]
    fn test_parse_destination_no_match() {
        let line = "[download] 50% of 5.00MiB";
        assert_eq!(parse_destination(line), None);
    }

    #[test]
    fn test_parse_progress_valid_line() {
        let line = "[download]  50.0% of 5.00MiB at 1.00MiB/s ETA 00:02";
        let progress = parse_progress(line).expect("Should parse valid progress");
        assert!((progress.percent - 0.5).abs() < 0.01);
        assert_eq!(progress.speed, Some("1.00MiB/s".to_string()));
        assert_eq!(progress.eta, Some("00:02".to_string()));
    }

    #[test]
    fn test_parse_progress_100_percent() {
        let line = "[download] 100% of 5.00MiB in 00:05";
        let progress = parse_progress(line).expect("Should parse 100% progress");
        assert!((progress.percent - 1.0).abs() < 0.01);
    }

    #[test]
    fn test_parse_progress_invalid_line() {
        let line = "[info] Extracting URL: https://soundcloud.com/...";
        assert!(parse_progress(line).is_none());
    }

    #[test]
    fn test_parse_progress_no_percentage() {
        let line = "[download] Downloading video 1 of 1";
        assert!(parse_progress(line).is_none());
    }

    #[test]
    fn test_parse_progress_small_percentage() {
        let line = "[download]   1.5% of 10.00MiB at 500KiB/s ETA 00:20";
        let progress = parse_progress(line).expect("Should parse small percentage");
        assert!((progress.percent - 0.015).abs() < 0.001);
    }

    #[test]
    fn test_bytes_to_string_valid_utf8() {
        let bytes = b"Hello, World!";
        assert_eq!(bytes_to_string(bytes), "Hello, World!");
    }

    #[test]
    fn test_bytes_to_string_with_newline() {
        let bytes = b"2026.02.04\n";
        assert_eq!(bytes_to_string(bytes), "2026.02.04\n");
    }

    #[test]
    fn test_detect_geo_block_not_available_country() {
        let stderr = "ERROR: This track is not available in your country";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_geo_restricted() {
        let stderr = "ERROR: Video geo restricted";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_geo_restricted_hyphen() {
        let stderr = "ERROR: This content is geo-restricted";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_not_available_region() {
        let stderr = "ERROR: Content not available in your region";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_blocked_country() {
        let stderr = "This track is blocked in your country";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_not_available_location() {
        let stderr = "ERROR: This content is not available in your location";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_not_available_playback() {
        let stderr = "ERROR: Track is not available for playback";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_case_insensitive() {
        let stderr = "ERROR: This track is NOT AVAILABLE IN YOUR COUNTRY";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_returns_message() {
        let stderr = "ERROR: This track is not available in your country";
        let result = detect_geo_block(stderr);
        assert_eq!(result, Some("Geographic restriction by rights holder".to_string()));
    }

    #[test]
    fn test_detect_geo_block_no_match() {
        let stderr = "ERROR: Network timeout";
        assert!(detect_geo_block(stderr).is_none());
    }

    #[test]
    fn test_detect_geo_block_empty_string() {
        assert!(detect_geo_block("").is_none());
    }

    #[test]
    fn test_detect_geo_block_unrelated_error() {
        let stderr = "ERROR: Unable to download webpage: HTTP Error 500";
        assert!(detect_geo_block(stderr).is_none());
    }

    // Unavailability detection tests

    #[test]
    fn test_detect_unavailability_video_unavailable() {
        let stderr = "ERROR: Video unavailable";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_this_video_not_available() {
        let stderr = "ERROR: This video is not available";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_private_video() {
        let stderr = "ERROR: Private video. Sign in if you've been granted access to this video";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_track_removed() {
        let stderr = "ERROR: This track was removed by the uploader";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_does_not_exist() {
        let stderr = "ERROR: This page does not exist";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_video_is_unavailable() {
        let stderr = "ERROR: Video is unavailable";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_content_not_available() {
        let stderr = "ERROR: Content is not available";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_has_been_removed() {
        let stderr = "ERROR: This content has been removed";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_no_longer_available() {
        let stderr = "ERROR: This track is no longer available";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_track_is_private() {
        let stderr = "ERROR: Track is private";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_is_private() {
        let stderr = "ERROR: This content is private";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_case_insensitive() {
        let stderr = "ERROR: VIDEO UNAVAILABLE";
        assert!(detect_unavailability(stderr).is_some());
    }

    #[test]
    fn test_detect_unavailability_returns_message() {
        let stderr = "ERROR: Video unavailable";
        let result = detect_unavailability(stderr);
        assert_eq!(
            result,
            Some("Track unavailable - may have been removed or made private".to_string())
        );
    }

    #[test]
    fn test_detect_unavailability_no_match() {
        let stderr = "ERROR: Network timeout";
        assert!(detect_unavailability(stderr).is_none());
    }

    #[test]
    fn test_detect_unavailability_empty_string() {
        assert!(detect_unavailability("").is_none());
    }

    #[test]
    fn test_detect_unavailability_unrelated_error() {
        let stderr = "ERROR: Unable to download webpage: HTTP Error 500";
        assert!(detect_unavailability(stderr).is_none());
    }

    #[test]
    fn test_detect_unavailability_does_not_match_geo_block() {
        // Geo-block patterns should NOT trigger unavailability detection
        let stderr = "ERROR: This track is not available in your country";
        assert!(detect_unavailability(stderr).is_none());
    }
}
