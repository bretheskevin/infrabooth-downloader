use std::path::PathBuf;
use tauri::{AppHandle, Emitter};
use tauri_plugin_shell::{process::CommandEvent, ShellExt};

use crate::models::error::YtDlpError;
use crate::services::storage::load_tokens;

/// Playlist context for track numbering.
#[derive(Debug, Clone)]
pub struct PlaylistContext {
    /// 1-indexed position in playlist
    pub track_position: u32,
    /// Total number of tracks in playlist
    pub total_tracks: u32,
}

/// Configuration for downloading a track directly to final MP3 output.
pub struct TrackDownloadToMp3Config {
    pub track_url: String,
    pub track_id: String,
    pub output_dir: PathBuf,
    /// Playlist context for track numbering (None for single tracks)
    pub playlist_context: Option<PlaylistContext>,
}

/// Progress update from yt-dlp.
#[derive(Debug, Clone, serde::Serialize)]
pub struct DownloadProgress {
    pub percent: f32,
    pub speed: Option<String>,
    pub eta: Option<String>,
}

/// Download progress event payload for frontend communication.
#[derive(Debug, Clone, serde::Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DownloadProgressEvent {
    pub track_id: String,
    pub status: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub percent: Option<f32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<DownloadErrorPayload>,
}

/// Error payload for download progress events.
#[derive(Debug, Clone, serde::Serialize)]
pub struct DownloadErrorPayload {
    pub code: String,
    pub message: String,
}

/// Build the output template for yt-dlp based on context.
///
/// - Single track: `Artist - Title.mp3`
/// - Playlist track: `01 - Artist - Title.mp3` (zero-padded based on total)
fn build_output_template(output_dir: &PathBuf, playlist_context: &Option<PlaylistContext>) -> String {
    let dir_str = output_dir.to_string_lossy();

    match playlist_context {
        Some(ctx) => {
            // Determine padding width based on total tracks
            let width = if ctx.total_tracks < 10 {
                1
            } else if ctx.total_tracks < 100 {
                2
            } else {
                3
            };
            // Use yt-dlp's playlist_index with zero-padding
            format!(
                "{}/%(playlist_index)0{}d - %(artist,uploader)s - %(title)s.%(ext)s",
                dir_str, width
            )
        }
        None => {
            // Single track: Artist - Title.mp3
            format!("{}/%(artist,uploader)s - %(title)s.%(ext)s", dir_str)
        }
    }
}

/// Download a track directly to MP3 format using yt-dlp with OAuth authentication.
///
/// This function downloads and converts to MP3 in a single step using yt-dlp's
/// built-in conversion with 320kbps bitrate. Filenames are generated by yt-dlp
/// from track metadata with cross-platform sanitization.
///
/// Progress events are emitted via Tauri events to the frontend.
pub async fn download_track_to_mp3<R: tauri::Runtime>(
    app: &AppHandle<R>,
    config: TrackDownloadToMp3Config,
) -> Result<PathBuf, YtDlpError> {
    let tokens = load_tokens()
        .map_err(|_| YtDlpError::AuthRequired)?
        .ok_or(YtDlpError::AuthRequired)?;

    let output_template = build_output_template(&config.output_dir, &config.playlist_context);

    let mut args = vec![
        "--no-playlist".to_string(),
        "-x".to_string(),
        "--audio-format".to_string(),
        "mp3".to_string(),
        "--audio-quality".to_string(),
        "320K".to_string(),
        "--add-header".to_string(),
        format!("Authorization: OAuth {}", tokens.access_token),
        "-o".to_string(),
        output_template,
        // Cross-platform filename sanitization (removes :, *, ?, etc.)
        "--windows-filenames".to_string(),
        // Don't overwrite existing files
        "--no-overwrites".to_string(),
        "--newline".to_string(),
        config.track_url.clone(),
    ];

    // Add playlist index if in playlist context
    if let Some(ctx) = &config.playlist_context {
        args.insert(0, "--playlist-items".to_string());
        args.insert(1, ctx.track_position.to_string());
    }

    let shell = app.shell();
    let (mut rx, _child) = shell
        .sidecar("yt-dlp")
        .map_err(|_| YtDlpError::BinaryNotFound)?
        .args(&args)
        .spawn()
        .map_err(|_| YtDlpError::BinaryNotFound)?;

    let mut last_error: Option<String> = None;
    let mut output_path: Option<PathBuf> = None;

    while let Some(event) = rx.recv().await {
        match event {
            CommandEvent::Stdout(line_bytes) => {
                let line = bytes_to_string(&line_bytes);

                // Parse the destination path from yt-dlp output
                if let Some(path) = parse_destination(&line) {
                    output_path = Some(PathBuf::from(path));
                }

                if let Some(progress) = parse_progress(&line) {
                    let _ = app.emit(
                        "download-progress",
                        DownloadProgressEvent {
                            track_id: config.track_id.clone(),
                            status: "downloading".to_string(),
                            percent: Some(progress.percent),
                            error: None,
                        },
                    );
                }
            }
            CommandEvent::Stderr(line_bytes) => {
                let line = bytes_to_string(&line_bytes);
                log::debug!("yt-dlp stderr: {}", line);
                last_error = Some(line.clone());

                // Check for geo-block patterns first (most specific)
                if detect_geo_block(&line).is_some() {
                    log::info!("Track {} geo-blocked in region", config.track_id);
                    return Err(YtDlpError::GeoBlocked);
                }
                // HTTP 403 can also indicate geo-block
                if line.contains("HTTP Error 403") {
                    log::info!("Track {} geo-blocked (HTTP 403)", config.track_id);
                    return Err(YtDlpError::GeoBlocked);
                }
                if line.contains("HTTP Error 429") || line.contains("rate limit") {
                    return Err(YtDlpError::RateLimited);
                }
                if line.contains("HTTP Error 404") {
                    return Err(YtDlpError::NotFound);
                }
            }
            CommandEvent::Terminated(payload) => {
                if payload.code != Some(0) {
                    log::error!(
                        "yt-dlp terminated with code {:?}: {:?}",
                        payload.code,
                        last_error
                    );
                    return Err(YtDlpError::DownloadFailed(
                        last_error.unwrap_or_else(|| "Unknown error".to_string()),
                    ));
                }
            }
            _ => {}
        }
    }

    // Verify output file exists
    let final_path = output_path.ok_or_else(|| {
        YtDlpError::DownloadFailed("Could not determine output filename".to_string())
    })?;

    if !final_path.exists() {
        return Err(YtDlpError::DownloadFailed(
            "Output file was not created".to_string(),
        ));
    }

    Ok(final_path)
}

/// Get the yt-dlp version.
pub async fn get_version<R: tauri::Runtime>(
    app: &tauri::AppHandle<R>,
) -> Result<String, YtDlpError> {
    let shell = app.shell();
    let (mut rx, _child) = shell
        .sidecar("yt-dlp")
        .map_err(|_| YtDlpError::BinaryNotFound)?
        .args(["--version"])
        .spawn()
        .map_err(|_| YtDlpError::BinaryNotFound)?;

    let mut version = String::new();

    while let Some(event) = rx.recv().await {
        match event {
            CommandEvent::Stdout(line_bytes) => {
                let line = bytes_to_string(&line_bytes);
                version = line.trim().to_string();
            }
            CommandEvent::Terminated(payload) => {
                if payload.code != Some(0) {
                    return Err(YtDlpError::BinaryNotFound);
                }
            }
            _ => {}
        }
    }

    if version.is_empty() {
        return Err(YtDlpError::BinaryNotFound);
    }

    Ok(version)
}

fn bytes_to_string(bytes: &[u8]) -> String {
    String::from_utf8_lossy(bytes).to_string()
}

/// Parse the destination path from yt-dlp output.
///
/// Looks for lines like: `[download] Destination: /path/to/file.mp3`
/// or `[ExtractAudio] Destination: /path/to/file.mp3`
fn parse_destination(line: &str) -> Option<String> {
    if line.contains("Destination:") {
        line.split("Destination:")
            .nth(1)
            .map(|s| s.trim().to_string())
    } else {
        None
    }
}

/// Detect geographic restriction from yt-dlp stderr output.
///
/// Returns Some with a user-friendly message if geo-block patterns are found.
fn detect_geo_block(stderr: &str) -> Option<String> {
    let patterns = [
        "not available in your country",
        "geo restricted",
        "geo-restricted",
        "not available in your region",
        "blocked in your country",
        "not available in your location",
        "is not available for playback",
        "not available in this country",
    ];

    let stderr_lower = stderr.to_lowercase();
    for pattern in patterns {
        if stderr_lower.contains(pattern) {
            return Some("Geographic restriction by rights holder".to_string());
        }
    }
    None
}

fn parse_progress(line: &str) -> Option<DownloadProgress> {
    if !line.contains("[download]") || !line.contains('%') {
        return None;
    }

    let parts: Vec<&str> = line.split_whitespace().collect();

    let percent = parts.iter().find_map(|part| {
        if part.ends_with('%') {
            part.trim_end_matches('%').parse::<f32>().ok()
        } else {
            None
        }
    })?;

    let speed = parts
        .iter()
        .position(|&p| p == "at")
        .and_then(|i| parts.get(i + 1))
        .map(|s| s.to_string());

    let eta = parts
        .iter()
        .position(|&p| p == "ETA")
        .and_then(|i| parts.get(i + 1))
        .map(|s| s.to_string());

    Some(DownloadProgress {
        percent: percent / 100.0,
        speed,
        eta,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_output_template_single_track() {
        let output_dir = PathBuf::from("/downloads");
        let template = build_output_template(&output_dir, &None);
        assert_eq!(
            template,
            "/downloads/%(artist,uploader)s - %(title)s.%(ext)s"
        );
    }

    #[test]
    fn test_build_output_template_playlist_single_digit() {
        let output_dir = PathBuf::from("/downloads");
        let ctx = Some(PlaylistContext {
            track_position: 1,
            total_tracks: 5,
        });
        let template = build_output_template(&output_dir, &ctx);
        assert_eq!(
            template,
            "/downloads/%(playlist_index)01d - %(artist,uploader)s - %(title)s.%(ext)s"
        );
    }

    #[test]
    fn test_build_output_template_playlist_double_digit() {
        let output_dir = PathBuf::from("/downloads");
        let ctx = Some(PlaylistContext {
            track_position: 5,
            total_tracks: 47,
        });
        let template = build_output_template(&output_dir, &ctx);
        assert_eq!(
            template,
            "/downloads/%(playlist_index)02d - %(artist,uploader)s - %(title)s.%(ext)s"
        );
    }

    #[test]
    fn test_build_output_template_playlist_triple_digit() {
        let output_dir = PathBuf::from("/downloads");
        let ctx = Some(PlaylistContext {
            track_position: 1,
            total_tracks: 150,
        });
        let template = build_output_template(&output_dir, &ctx);
        assert_eq!(
            template,
            "/downloads/%(playlist_index)03d - %(artist,uploader)s - %(title)s.%(ext)s"
        );
    }

    #[test]
    fn test_parse_destination_download() {
        let line = "[download] Destination: /path/to/Artist - Title.mp3";
        assert_eq!(
            parse_destination(line),
            Some("/path/to/Artist - Title.mp3".to_string())
        );
    }

    #[test]
    fn test_parse_destination_extract_audio() {
        let line = "[ExtractAudio] Destination: /path/to/file.mp3";
        assert_eq!(
            parse_destination(line),
            Some("/path/to/file.mp3".to_string())
        );
    }

    #[test]
    fn test_parse_destination_no_match() {
        let line = "[download] 50% of 5.00MiB";
        assert_eq!(parse_destination(line), None);
    }

    #[test]
    fn test_parse_progress_valid_line() {
        let line = "[download]  50.0% of 5.00MiB at 1.00MiB/s ETA 00:02";
        let progress = parse_progress(line).expect("Should parse valid progress");
        assert!((progress.percent - 0.5).abs() < 0.01);
        assert_eq!(progress.speed, Some("1.00MiB/s".to_string()));
        assert_eq!(progress.eta, Some("00:02".to_string()));
    }

    #[test]
    fn test_parse_progress_100_percent() {
        let line = "[download] 100% of 5.00MiB in 00:05";
        let progress = parse_progress(line).expect("Should parse 100% progress");
        assert!((progress.percent - 1.0).abs() < 0.01);
    }

    #[test]
    fn test_parse_progress_invalid_line() {
        let line = "[info] Extracting URL: https://soundcloud.com/...";
        assert!(parse_progress(line).is_none());
    }

    #[test]
    fn test_parse_progress_no_percentage() {
        let line = "[download] Downloading video 1 of 1";
        assert!(parse_progress(line).is_none());
    }

    #[test]
    fn test_parse_progress_small_percentage() {
        let line = "[download]   1.5% of 10.00MiB at 500KiB/s ETA 00:20";
        let progress = parse_progress(line).expect("Should parse small percentage");
        assert!((progress.percent - 0.015).abs() < 0.001);
    }

    #[test]
    fn test_bytes_to_string_valid_utf8() {
        let bytes = b"Hello, World!";
        assert_eq!(bytes_to_string(bytes), "Hello, World!");
    }

    #[test]
    fn test_bytes_to_string_with_newline() {
        let bytes = b"2026.02.04\n";
        assert_eq!(bytes_to_string(bytes), "2026.02.04\n");
    }

    #[test]
    fn test_detect_geo_block_not_available_country() {
        let stderr = "ERROR: This track is not available in your country";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_geo_restricted() {
        let stderr = "ERROR: Video geo restricted";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_geo_restricted_hyphen() {
        let stderr = "ERROR: This content is geo-restricted";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_not_available_region() {
        let stderr = "ERROR: Content not available in your region";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_blocked_country() {
        let stderr = "This track is blocked in your country";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_not_available_location() {
        let stderr = "ERROR: This content is not available in your location";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_not_available_playback() {
        let stderr = "ERROR: Track is not available for playback";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_case_insensitive() {
        let stderr = "ERROR: This track is NOT AVAILABLE IN YOUR COUNTRY";
        assert!(detect_geo_block(stderr).is_some());
    }

    #[test]
    fn test_detect_geo_block_returns_message() {
        let stderr = "ERROR: This track is not available in your country";
        let result = detect_geo_block(stderr);
        assert_eq!(result, Some("Geographic restriction by rights holder".to_string()));
    }

    #[test]
    fn test_detect_geo_block_no_match() {
        let stderr = "ERROR: Network timeout";
        assert!(detect_geo_block(stderr).is_none());
    }

    #[test]
    fn test_detect_geo_block_empty_string() {
        assert!(detect_geo_block("").is_none());
    }

    #[test]
    fn test_detect_geo_block_unrelated_error() {
        let stderr = "ERROR: Unable to download webpage: HTTP Error 500";
        assert!(detect_geo_block(stderr).is_none());
    }
}
