// @ts-nocheck
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Starts the OAuth flow by generating PKCE parameters and returning the auth URL.
 * 
 * The PKCE code verifier is stored in the app state for later use during token exchange.
 * 
 * # Returns
 * * `Ok(String)` - The authorization URL to open in the browser
 * * `Err(String)` - Error message if generation fails
 */
async startOauth() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_oauth") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Completes the OAuth flow by exchanging the authorization code for tokens.
 * 
 * Retrieves the stored PKCE verifier, exchanges the code for tokens,
 * and emits an auth state change event to the frontend.
 * 
 * # Arguments
 * * `code` - The authorization code received from the OAuth callback
 * 
 * # Returns
 * * `Ok(())` - If token exchange succeeds
 * * `Err(String)` - Error message if exchange fails
 */
async completeOauth(code: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("complete_oauth", { code }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks authentication state on app startup.
 * 
 * Loads stored tokens from the OS keychain, checks if they're valid,
 * and refreshes them if needed. Emits auth state to the frontend.
 * 
 * # Returns
 * * `Ok(true)` - User is authenticated (tokens valid or refreshed)
 * * `Ok(false)` - User is not authenticated (no tokens or refresh failed)
 * * `Err(String)` - Error during the check
 */
async checkAuthState() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_auth_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Signs out the user by deleting stored tokens and emitting signed-out state.
 * 
 * This command:
 * 1. Deletes tokens from the OS keychain
 * 2. Emits an auth-state-changed event with signed-out state
 * 
 * # Returns
 * * `Ok(())` - If sign-out succeeds
 * * `Err(String)` - Error message if sign-out fails
 */
async signOut() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("sign_out") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validateSoundcloudUrl(url: string) : Promise<ValidationResult> {
    return await TAURI_INVOKE("validate_soundcloud_url", { url });
},
async getPlaylistInfo(url: string) : Promise<Result<PlaylistInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_playlist_info", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTrackInfo(url: string) : Promise<Result<TrackInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_track_info", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Test the yt-dlp sidecar by getting its version.
 */
async testYtdlp() : Promise<Result<string, ErrorResponse>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("test_ytdlp") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Test the FFmpeg sidecar by getting its version.
 * 
 * This command verifies that the FFmpeg binary is properly bundled
 * and can be executed as a Tauri sidecar.
 */
async testFfmpeg() : Promise<Result<string, ErrorResponse>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("test_ffmpeg") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Download and convert a track to MP3 with metadata embedding.
 * 
 * This command orchestrates the full download pipeline:
 * 1. Downloads audio using yt-dlp with OAuth authentication
 * 2. Converts to high-quality MP3 using yt-dlp native conversion
 * 3. Embeds ID3 metadata (title, artist, album, track number, artwork)
 * 4. Emits progress events throughout the process
 */
async downloadTrackFull(request: DownloadRequest) : Promise<Result<string, ErrorResponse>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("download_track_full", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Start processing a download queue.
 * 
 * This command accepts a list of tracks and processes them sequentially.
 * Progress events are emitted via:
 * - `queue-progress`: Overall queue progress (X of Y)
 * - `download-progress`: Per-track status
 * - `queue-complete`: Final results when queue finishes
 * - `queue-cancelled`: When queue is cancelled by user
 */
async startDownloadQueue(request: StartQueueRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_download_queue", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Cancel the current download queue.
 */
async cancelDownloadQueue() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_download_queue") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Respond to an auth choice prompt during download.
 */
async respondToAuthChoice(choice: AuthChoice) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("respond_to_auth_choice", { choice }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkWritePermission(path: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_write_permission", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDefaultDownloadPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_default_download_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validateDownloadPath(path: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_download_path", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks for available updates.
 * 
 * # Returns
 * * `Ok(Some(UpdateInfo))` - Update available with version, notes, and date
 * * `Ok(None)` - No update available
 * * `Err(String)` - Error message if check fails
 */
async checkForUpdates() : Promise<Result<UpdateInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_for_updates") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Downloads and installs an available update.
 * 
 * This will download the update in the background and install it.
 * On most platforms, the app will need to restart to apply the update.
 * 
 * # Returns
 * * `Ok(())` - Update downloaded and installed successfully
 * * `Err(String)` - Error message if installation fails
 */
async installUpdate() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("install_update") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AuthChoice = "re_authenticated" | "continue_standard"
export type DownloadRequest = { trackUrl: string; trackId: string; title: string; artist: string; album: string | null; trackNumber: number | null; totalTracks: number | null; artworkUrl: string | null; outputDir: string | null }
export type ErrorResponse = { code: string; message: string }
/**
 * Playlist information from SoundCloud API.
 */
export type PlaylistInfo = { id: number; title: string; user: UserInfo; artwork_url: string | null; track_count: number; tracks: TrackInfo[] }
export type QueueItemRequest = { trackUrl: string; trackId: string; title: string; artist: string; artworkUrl: string | null }
export type StartQueueRequest = { tracks: QueueItemRequest[]; albumName: string | null; outputDir: string | null }
/**
 * Track information from SoundCloud API.
 */
export type TrackInfo = { id: number; title: string; user: UserInfo; artwork_url: string | null; 
/**
 * Duration in milliseconds.
 */
duration: number }
/**
 * Information about an available update.
 */
export type UpdateInfo = { version: string; body: string | null; date: string | null }
export type UrlType = "playlist" | "track"
/**
 * User information from SoundCloud API (public).
 */
export type UserInfo = { username: string }
export type ValidationError = { code: string; message: string; hint: string | null }
export type ValidationResult = { valid: boolean; urlType: UrlType | null; error: ValidationError | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
